{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1712670027519488002",
        "title": "RBAC 基础 -权限控制",
        "description": null,
        "content": "## RBAC 角色权限控制\n\n### 1. 什么是 RBAC\n\nRBAC（Role-Based Access Control，基于角色的访问控制），是一种新的访问控制机制，\n它是以角色为中心来进行访问控制的，即用户通过角色与权限进行关联，进而获得权限，从而访问系统资源。\n\n#### 什么是ABAC(扩展--->框架少,实现比较困难,开发成本高,但一旦实现,可以实现很多复杂的控制)\n\nABAC（Attribute-Based Access Control，基于属性的访问控制），是一种新的访问控制机制，\n它是以属性为中心来进行访问控制的，即用户通过属性与权限进行关联，进而获得权限，从而访问系统资源。\n\n\n### 2. RBAC 的优点\n\nRBAC 的优点主要有以下几点：\n\n- 降低了复杂性：\n- 降低了维护成本\n- 降低了风险：\n- 降低了开发成本\n- 降低了运维成本\n- 降低了安全风险\n- 降低了系统复杂度\n- 降低了系统的耦合度\n- 降低了系统的依赖性\n\n### 3. RBAC 的分级\n- RBAC0：基本的RBAC模型，只有用户、角色、权限三个基本元素，是最简单的RBAC模型。\n- RBAC1：在RBAC0的基础上增加了角色继承，即角色可以继承其他角色的权限。\n- RBAC2：在RBAC1的基础上增加了用户-角色绑定，即用户可以绑定多个角色。\n- RBAC3：在RBAC2的基础上增加了约束，即角色可以绑定多个用户，但是每个用户对于某个角色的绑定都有时间上的限制。\n\n\n### 3. RABC 的核心\n\n- 用户（User）：用户是指系统的使用者，可以是一个人，也可以是一台机器，或者其他什么东西。\n- 角色（Role）：角色是指用户的职责或者角色，一个用户可以有多个角色，一个角色可以包含多个用户。\n- 权限（Permission）：权限是指用户在某个角色上可以执行的操作，一个角色可以包含多个权限，一个权限可以包含多个角色。\n- 资源（Resource）：资源是指用户可以访问的系统资源，比如文件、目录、数据库等。\n- 操作（Operation）：操作是指用户对资源可以执行的操作，比如读、写、执行等。\n- 会话（Session）：会话是指用户在一段时间内的访问，一般来说，用户登录系统后，就会建立一个会话，直到用户退出系统，这个过程就是一个会话。\n- 会话管理（Session Management）：会话管理是指对用户的会话进行管理，包括建立会话、维护会话、销毁会话等。\n- 会话控制（Session Control）：会话控制是指对用户的会话进行控制，包括会话的访问控制、会话的权限控制等。\n- 会话访问控制（Session Access Control）：会话访问控制是指对用户的会话进行访问控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限控制（Session Permission Control）：会话权限控制是指对用户的会话进行权限控制，包括会话的访问控制、会话的权限控制等。\n- 会话权限管理（Session Permission Management）：会话权限管理是指对用户的会话进行权限管理，包括会话的访问控制、会话的权限控制等。\n- 会话权限分配（Session Permission Assignment）：会话权限分配是指对用户的会话进行权限分配，包括会话的访问控制、会话的权限控制等。\n\n### 4. RBAC 的实现\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 19,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T03:22:09.000+00:00",
        "updateTime": "2023-10-18T07:39:46.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-13T03:33:21.000+00:00"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712664270979854337",
        "title": "NoSqol-Redis 基础",
        "description": "NoSql -Redis",
        "content": "## NoSql\n\n### 什么是NoSQL\n- NoSQL(Not only SQL):不仅仅是Sql,是对不同于传统的关系数据库(以二维表结构展示)的数据库管理系统的统称\n- NoSql 与Sql 之间不是对立关系,而是作为Sql的补充,满足在特殊需求上,Sql实现复杂,效率低等问题...\n\n### 常见类型的NoSql\n\n- 键值数据库 以 key-value 的形式存储数据  -->Redis\n- 文档数据库 以Document的形式存储  --->MongoDB,Elasticsearch\n- 图类型数据库 图结构  --->Neo4J\n- 列族数据库 以列族式存储，将同一列数据存在一起 -->HBase\n\n 扩展:\n \n     1 .https://blog.csdn.net/weixin_44259720/article/details/104839050\n     2. https://zhuanlan.zhihu.com/p/345342966\n## Redis\n\n### 什么是Redis\n- 以 key-value 形式存储,和传统的关系型数据库不一样.不一定遵循传统数据库的一些基本要求.(非关系型的,分布式的,开源的,水平可拓展的)\n\n- Redis 是以 key-value store 存储.\n        \n        键可以包含:(string)字符串,哈希,(list)链表,(set)集合,(zset)有序集合.\n        这些数据集合都指出push/pop,add/remove及取交集和并集以及更丰富的操作.\n        redis支持各种不同方式排序,为了保证效率,数据都是缓存在内存中.\n        它可以从周期性的把更新的数据写入到磁盘或者把修改操作写入追加的文件中.\n### 优缺点\n\n\n- 优点:\n\n```text\n高并发读写\n海量数据的高效率存储和访问\n数据的可拓展性和高可用性\n单线程操作,每个操作都是原子操作,没有并发相关问题\n```\n\n- 缺点:\n```text\n事务处理非常简单\n无法做太复杂的关系数据库模型\n基于内存容易丢失数据\n```\n\n### 使用场景\n\n#### 缓存中间件\n\n- Redis 缓存的优缺点\n```text\n\t优点\n\t\t提高查询性能, 减少 IO 操作\n\t\t减轻 MySQL 数据库负担\n\t\t减轻应用服务器 cpu & 内存负担\n\t缺点\n\t\t数据一致性问题\n\t\t可能丢失数据\n```\n- 什么数据适合做缓存?\n```text\n\t查询频率高\n\t修改频率低\n\t一致性要求较低\n```\n- 缓存操作流程\n```text\n\t1. 读取 redis 数据，有则直接返回\n\t2. redis 中没有，查询 mysql 数据库\n\t3. 将 mysql 数据库的数据存储到 redis\n\t4. 返回该数据\n```\n\n### NoSql\n\n- NoSQL 应用场景\n 1. 数据频繁更新且一致性要求不高\n \n\t\t阅读数/评论数/分享数等\n\t\t接口限流\n2. 基于 List 实现栈/队列等特殊结构\n3. 基于经纬度的地理位置操作--->Redis GEO\n\n\n\n\n\n\n# 常见命令和基本五大数据类型\n \n### 全局命令\n\n| 命令               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `PING`             | 测试连接是否正常                                             |\n| `INFO`             | 获取服务器信息                                               |\n| `FLUSHALL`         | 删除所有数据库的所有数据                                     |\n| `FLUSHDB`          | 删除当前数据库的所有数据                                     |\n| `SELECT`           | 选择数据库                                                   |\n| `AUTH`             | 使用密码进行认证                                             |\n| `KEYS`             | 查找所有符合给定模式的键                                     |\n| `EXPIRE`           | 设置键的过期时间                                             |\n| `TTL`              | 获取键的剩余过期时间                                         |\n| `DEL`              | 删除键                                                       |\n| `RENAME`           | 重命名键                                                     |\n| `DBSIZE`           | 获取当前数据库中键的数量                                     |\n| `SCAN`             | 迭代数据库中的键                                             |\n| `EVAL`             | 执行Lua脚本                                                  |\n| `SCRIPT LOAD`      | 加载Lua脚本                                                  |\n| `SCRIPT EXECUTE`   | 执行已加载的Lua脚本                                          |\n| exists key         | 判断 key 是否存在, 返回 1 或 0, 1表示存在, 0表示不存在       |\n| ttl key            | 返回指定 key 还有多少秒过期, 如果已经过期或者不存在, 返回 -2, 如果没有设置过期时间, 返回 -1 |\n| expire key seconds | 为指定 key 设置过期时间为 seconds 秒, 如果之前已经设置了过期时间, 会直接覆盖之前的 |\n| flushdb            | 清除 redis                                                   |\n| keys pattern       | 按照指定格式扫描所有 key, 返回匹配的 key 集合                |\n\n### 常用数据类型命令\n\n### String\n\n| 命令                  | 描述                                             |\n|----------------------|--------------------------------------------------|\n| `SET key value`      | 存储一个键值对                                    |\n| `GET key`            | 获取指定键的值                                    |\n| `INCR key`           | 原子性地将键的值加1                               |\n| `DECR key`           | 原子性地将键的值减1                               |\n| `INCRBY key value`   | 原子性地将键的值增加指定值                        |\n| `DECRBY key value`   | 原子性地将键的值减少指定值                        |\n| `SETEX key seconds value` | 设置键值对的同时，设置过期时间               |\n| `SETNX key value`    | 如果键不存在则设置，返回1；如果键已存在则不设置，返回0（原子性操作） |\n| `MSET key1 value1...keyn valuen` | 设置多个键值对  |\n| `MGET key1 key2 keyn` | 获取多个指定键的值                             |\n\n#### 应用场景\n\n- 计数器（如浏览数、评论数、点赞数等）\n- 分布式自增ID生成器\n- 共享Session\n\n### Hash\n\n| 命令                          | 描述                                            |\n|------------------------------|-------------------------------------------------|\n| `HSET key field value`       | 存储一个键值对到hash结构，键名为key，字段为field，值为value |\n| `HGET key field`             | 获取指定hash结构中field的值                     |\n| `HKEYS key`                  | 获取hash结构下指定key的所有字段名                  |\n| `HVALS key`                  | 获取hash结构下指定key的所有字段值                  |\n| `HINCRBY key field value`    | 原子性地将指定hash结构key中的field增加value（field必须是数字） |\n| `HGETALL key`                | 一次性返回指定hash key中的所有键值对              |\n\n#### 应用场景\n\n- 存储复杂类型的属性\n- 减少外部键数量，通过hash对数据进行分类，将同一分类下的数据存储在hash中\n\n\n\n\n\n### List\n\n| 命令                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| `RPUSH key value...`    | 往列表（List）的最后添加一个或多个元素                       |\n| `LINDEX key index`      | 获取列表中指定索引位置的元素                                 |\n| `LRANGE key start stop` | 获取列表中从指定的 start 索引到 stop 索引位置范围内的所有元素 |\n| `LLEN key`              | 返回列表中的元素个数                                         |\n| `LREM key count value`  | 删除列表中指定值为 value 的元素                              |\n|                         | - count > 0：从头到尾删除 count 个元素                       |\n|                         | - count < 0：从尾到头删除 count 个元素                       |\n|                         | - count = 0：删除所有值为 value 的元素                       |\n| `LPUSH`/`RPOP`          | 用于实现队列，支持先进先出（FIFO）                           |\n| `LPUSH`/`BRPOP`         | 用于实现阻塞队列，支持先进先出（FIFO），在获取不到元素时线程会阻塞等待 |\n| `LPUSH`/`LPOP`          | 用于实现栈，支持先进后出（LIFO）                             |\n\n#### 应用场景\n\n- 用作各种列表类型的数据结构\n  - 普通列表\n  - 队列/阻塞队列\n  - 栈\n- 关注人集合/粉丝集合/收藏文章集合等\n  - 注意处理大键（Key）的情况\n\n\n\n\n\n### Set\n\n| 命令                    | 描述                                           |\n| ----------------------- | ---------------------------------------------- |\n| `SADD key members...`   | 往集合（Set）中添加一个或多个成员              |\n| `SCARD key`             | 返回集合中的成员数量                           |\n| `SMEMBERS key`          | 返回集合中的所有成员                           |\n| `SDIFF key1 key2`       | 返回两个集合 key1 和 key2 的差集               |\n| `SINTER key1 key2`      | 返回两个集合 key1 和 key2 的交集               |\n| `SUNION key1 key2`      | 返回两个集合 key1 和 key2 的并集               |\n| `SPOP key count`        | 随机移除并返回集合 key 中的 count 个成员       |\n| `SRANDMEMBER key count` | 随机返回集合 key 中的 count 个成员（允许重复） |\n\n#### 应用场景\n\n- 求交集、并集、差集的需求\n- 数据去重、获取随机数\n- 抽奖功能等\n\n\n\n### Sorted Set 类型(ZSet)\n\n| 命令                                 | 描述                                                   |\n| ------------------------------------ | ------------------------------------------------------ |\n| `ZADD key score value`               | 往有序集合（ZSet）中添加一个带有分数的成员             |\n| `ZCARD key`                          | 返回有序集合中的成员数量                               |\n| `ZCOUNT key min max`                 | 返回有序集合中分数在 min 和 max 之间的成员数量         |\n| `ZINCRBY key score value`            | 为有序集合中的指定成员增加分数                         |\n| `ZRANGE key startIndex stopIndex`    | 根据分数从小到大的排序，返回有序集合的指定成员列表     |\n| `ZREVRANGE key startIndex stopIndex` | 根据分数从大到小的排序，返回有序集合的指定成员列表     |\n| `ZRANK key value`                    | 返回有序集合中指定成员的排名（从小到大的排序索引位置） |\n| `ZREVRANK key value`                 | 返回有序集合中指定成员的排名（从大到小的排序索引位置） |\n| `ZREM key value`                     | 从有序集合中删除指定成员                               |\n| `ZSCORE key value`                   | 返回有序集合中指定成员的分数                           |\n\n#### 应用场景\n\n- 排行榜应用场景，如游戏得分排名\n- 带权重的元素排序，如商品价格排名\n- 实时热门内容排行等\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:59:16.000+00:00",
        "updateTime": "2023-10-18T01:30:05.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-13T03:33:21.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis",
          "SQL"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1712659313811648513",
        "title": "RESTFUL-风格完成后端接口开发",
        "description": "REST ",
        "content": "## REST\n\n### REST风格 API接口开发\n\n#### 1. RESTful (核心思想===>表现层状态转换)\n\n1.1 RESTful是一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。\n\n1.2 RESTful是目前最流行的一种互联网软件架构。\n\n1.3 RESTful架构的核心原则：\n```text\n1- 以资源为中心，资源是指网络上的一个实体，或者说是网络上的一个具体信息。\n- 每个资源对应一个特定的资源路径，即URI。\n- 客户端和服务器之间，传递这种资源的某种表现层状态，即表现层状态转换。\n\n以资源为基础 ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，\n除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。\n\n2- 统一接口：统一接口是RESTful架构的基础，只要是符合RESTful架构原则的，都可以称为RESTful接口。\n- 统一接口包括：资源标识、资源操作、自描述消息、超媒体作为应用状态引擎。\n- 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。\n- GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。\n- DELETE（DELETE）：从服务器删除资源\n- 通过统一接口，实现了客户端和服务器的分离，使得客户端不用关心服务器的技术实现，而服务器也不用关心客户端的业务逻辑。\n```\n传统API接口开发和RESTful API接口开发对比：\n\n| 传统API接口开发 | RESTful API接口开发 |\n| :--- | :--- |\n| 以动作为中心 | 以资源为中心 |\n| 以动词为中心 | 以名词为中心 |\n| 以操作为中心 | 以数据为中心 |\n| 以过程为中心 | 以结果为中心 |\n| 以业务为中心 | 以实体为中心 |\n\n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/edLHAoeZ-image.png)\n\n#### 2. RESTful URI设计\n1. 不用大写字母，所有单词使用英文且小写。\n2. 连字符用中杠\"-\"而不用下杠\"_\"\n3. 正确使用 \"/\"表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定\n4. 结尾不要包含正斜杠分隔符\"/\"\n5. URL中不出现动词，用请求方式表示动作\n6. 资源表示用复数不要用单数\n7. 不要使用文件扩展名\n8. 用好HTTP状态码\n\n#### 3. RESTful 响应状态码\n使用RESTful风格的API接口开发，一般需要返回响应状态码和响应数据，\n响应状态码的使用非常重要，下面列举了常用的状态码：\n\n```text\n1. 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n2. 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n3. 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n4. 204 NO CONTENT - [DELETE]：用户删除数据成功。\n5. 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n6. 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n7. 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n8. 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n9. 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n10. 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n11. 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n12. 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n```\n\n#### 4.日常开发使用\n\nRestful 只是一种风格和规范,不是一种标准,不一定要让所有接口全部遵循,一般开发中混用.",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 12,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-13T02:39:34.000+00:00",
        "updateTime": "2023-10-16T07:32:21.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-13T03:33:21.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "API接口",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1710609924599443458",
        "title": "Spring -MVC",
        "description": null,
        "content": "## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n ```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n    1. 对象: {\"name\": \"张三\", \"age\": 18}\n    2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n    3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```\n\n## SpringMVC\n\n### SpringMVC基本原理\n\n#### MVC思想\n1. 前端发送请求--> 控制器统一处理--->调用模型方法,返回模型数据\n2. 后端把模型数据返还视图(web 中不支持)--->视图--->前端\n3. 控制器也可以选择视图 --->前端\n\n\n#### 为什么使用Spring-MVC\n1. 低耦合,灵活性和扩展性高\n2. 安全,效率高\n3. 与spring 无缝衔接\n### 前端控制器\n#### 有没有的区别\n1. 无:多个用户-->多个请求---> 多个servlet\n2. 有:多个用户-->多个请求---> 一个servlet\n\n\n#### 配置前端控制器\n1. 在 main 目录新建 webapp/WEB-INF/web.xml，内容如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n         version=\"3.0\">\n\n    <!-- Spring MVC 前端控制器-->\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!-- 指定 Spring 容器启动加载的配置文件-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:mvc.xml</param-value>\n        </init-param>\n        <!-- Tomcat 启动初始化 -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n\n2. 创建控制器类\n3. mvc.xml 配置文件\n```xml\n<!-- 配置 IoC DI 注解解析器，让 Spring 我们创建 HelloController 类的对象 -->\n<context:component-scan base-package=\"cn.wolfcode.web.controller\"/>\n\n        <!-- MVC 注解解析器 -->\n<mvc:annotation-driven/>\n```\n\n\n### 常用注解\n#### RequestMapping 注解\n\nRequestMapping 注解是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。还可以限定请求类型和响应类型等。\n\n#### @ResponseBody注解\n\n将方法的返回值转换成json并响应给浏览器\n\n#### MVC 注解解析器\n\n配置了会往容器中存入 RequestMappingHandlerMapping、RequestMappingHandlerAdapter、ExceptionHandlerExceptionResolver 等三个 bean。除此之外：\n- 支持使用 ConversionService 实例对表单参数进行类型转换。\n- 支持使用 @NumberFormat、@DateTimeFormat 注解完成数据格式化操作。\n- 支持使用 @Valid 注解对 JavaBean 实例进行 JSR303 验证。\n- 支持使用 @RequestBody 和 @ResponseBody 注解读写 JSON。\n\n\n### 参数接受\n#### 基本类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 包装类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 数组类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 集合类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 自定义类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n\n#### 时间类型\n1. 通过参数名接受参数\n2. 通过注解接受参数\n```text\n@DateTimeFormat(pattern = \"yyyy-MM-dd\")\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 31,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-07T10:56:02.000+00:00",
        "updateTime": "2023-10-18T03:56:13.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-13T03:33:21.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1710587358686081026",
        "title": "Java -Spring-boot",
        "description": "Springboot 和集成SSm",
        "content": "## Spring-Boot\n\n### 1. Spring-Boot简介\nSpring-Boot是Spring官方提供的一个快速开发脚手架，可以基于Spring-Boot快速开发单个微服务。\n使用目的:简化Spring应用的初始搭建以及开发过程。如配置文件的配置，繁琐的依赖配置等。\n\n### 2. Spring-Boot特点\n1. 独立运行的Spring项目\n2. 内嵌Tomcat、Jetty或Undertow，不需要部署WAR文件\n3. 提供运行时的应用监控\n4. 提供starter简化Maven配置\n5. 自动配置Spring\n\n### 3.AppConfig.java 配置类\n1. @Configuration:声明当前类是一个配置类，相当于Spring配置的xml文件\n2. @Bean:声明在方法上，将方法的返回值加入Bean容器，相当于Spring配置的<bean>标签\n2.1 @Bean(name=\"user\")：指定Bean的名称，如果不指定，Bean的名称默认为方法名\n2.2 @Bean(name=\"user\",initMethod=\"init\",destroyMethod=\"destroy\")：指定Bean的初始化方法和销毁方法\n2.3 关联其他Bean：\n3. @ComponentScan:自动扫描包，相当于Spring配置的<context:component-scan>标签\n```java\n// 方式一： 调用方法注入 关联的bean\n@Bean\npublic User user(){\n    return new User();\n}\n@Bean\npublic UserService userService(){\n    UserService userService = new UserService();\n    userService.setUser(user());\n    return userService;\n}\n\n// 方式二：通过方法形参注入 关联的bean\n@Bean\npublic UserService userService(User user){\n    UserService userService = new UserService();\n    userService.setUser(user);\n    return userService;\n}\n```\n\n### 4.测试类Junit4和Junit5\n```java\n// Junit4\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = AppConfig.class)\n// Junit5\n@SpringBootTest(classes = AppConfig.class)\n```\n\n\n### 5.主配置中导入其他配置类或者配置文件\n```java\n// 方式一：通过@Import注解导入其他配置类\n@Configuration\n@Import({AppConfig2.class,AppConfig3.class})\n\n\n// 方式二：通过@ImportResource注解导入其他配置文件\n@Configuration\n@ImportResource(\"classpath:applicationContext.xml\")\n\n// 方式三：通过@PropertySource注解导入其他配置文件\n@Configuration\n@PropertySource(\"classpath:jdbc.properties\")\n```\n\n### 6.配置文件的优先级\n`properties`文件的优先级高于`yml`文件而以下四个位置的配置文件优先级高低顺序如下：\n1. 项目根目录下的config文件夹\n2. 项目根目录下\n3. classpath下的config文件夹\n4. classpath下\n\n### 7.读取配置文件(三种方式)\n```java\n// 方式一：通过@Value注解读取配置文件\n@Value(\"${name}\")\nprivate String name;\n\n// 方式二：通过Environment读取配置文件\n@Autowired\nprivate Environment env;\nenv.getProperty(\"name\");\n\n// 方式三：通过@ConfigurationProperties注解读取配置文件\n@ConfigurationProperties(prefix = \"user\")\n```\n\n## Spring-Boot 集成ssm\n### 1. Spring-Boot集成Mybatis\n1. 导入依赖\n```xml\n<!-- Spring-Boot集成Mybatis -->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n</dependency>\n```\n2. 配置数据源\n```yml\nspring:\n  datasource:\n    driver-class-name: com.mysql.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8&useSSL=false\n    username: root\n    password: 123456\n```\n3. 配置Mybatis\n```yml\nmybatis:\n  mapper-locations: classpath:mapper/*.xml\n  type-aliases-package: com.example.demo.entity\n```\n4. 编写Mapper接口和Mapper.xml文件\n```java\n// Mapper接口\npublic interface UserMapper {\n    List<User> findAll();\n}\n\n// Mapper.xml文件\n<mapper namespace=\"com.example.demo.mapper.UserMapper\">\n    <select id=\"findAll\" resultType=\"com.example.demo.entity.User\">\n        select * from user\n    </select>\n</mapper>\n```\n5.使用PageHelper分页插件\n```xml\n<!-- 使用PageHelper分页插件 -->\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper-spring-boot-starter</artifactId>\n</dependency>\n```\n\n### 2. Spring-Boot集成SpringMVC\n1. 导入依赖\n```xml\n<!-- Spring-Boot集成SpringMVC -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n2. 配置SpringMVC\n```java\n// 配置类\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"index\");\n    }\n}\n\n// 静态资源配置\nspring:\n  mvc:\n    static-path-pattern: /static/**\n    static-locations: classpath:/static/\n```\n3. 编写Controller\n```java\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model){\n        List<User> users = userService.findAll();\n        model.addAttribute(\"users\",users);\n        return \"userList\";\n    }\n}\n```\n\n### 3. 事务管理\n1. 导入依赖\n```xml\n<!-- 事务管理 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n2. 配置事务管理器\n```java\n// 配置类\n@Configuration\npublic class TransactionConfig {\n    @Autowired\n    private DataSource dataSource;\n\n    @Bean\n    public DataSourceTransactionManager transactionManager(){\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n```\n\n\n### 4.统一异常处理\n1. 编写异常处理类\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(Exception.class)\n    public String exceptionHandler(Exception e, Model model){\n        model.addAttribute(\"msg\",e.getMessage());\n        return \"error\";\n    }\n}\n```\n2. 拦截器配置\n```java\n// 配置类\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n### 5. 日志管理\n1. Slf4j日志\n2. 使用方式\n```xml\n// 方式一：直接使用\nprivate static final Logger logger = LoggerFactory.getLogger(UserController.class);\n\n// 方式二：使用注解\n@Slf4j\n```\n3. 日志级别\n```xml\n# 日志级别\nwarn\ninfo\ndebug\nerror\n```\n4.5、Logback 配置文件的使用\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\n    scan：开启日志框架的热部署，默认值 true 表示开启\n    scanPeriod：热部署的频率，默认值 60 second\n    debug：设置输出框架内部的日志，默认值 false\n-->\n<configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\">\n    <property name=\"appName\" value=\"springboot demo\" />\n    <contextName>${appName}</contextName>\n    \n    <!-- appender：日志输出对象，配置不同的类拥有不同的功能\n        ch.qos.logback.core.ConsoleAppender：日志输出到控制台        \n    -->\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%d{yyyy-MM-dd-HH：mm：ss} %level [%thread]-%logger{35} >> %msg %n</pattern>\n　　　　　</encoder>\n　　 </appender>\n    \n    <!-- ch.qos.logback.core.FileAppender：日志输出到文件中\n    <appender name=\"fileAppender\" class=\"ch.qos.logback.core.FileAppender\">\n        <encoder>\n            <pattern>%-4relative [%thread] %level %logger{35} - %msg %n</pattern>\n    　　 </encoder>\n        <append>true</append>\n        <file>mylog.log</file>\n　　 </appender>\n    -->\n    \n    <!-- \n        root 是项目通用的 logger，一般情况下都是使用 root 配置的日志输出\n        level：按照级别输出日志，日志级别，级别越高，输出的内容越少\n    -->\n　　 <root level=\"info\">\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n    \n    <!-- 自定义的 logger，用于专门输出特定包中打印的日志\n    <logger name=\"cn.wolfcode.crm.mapper\" level=\"trace\">\n    </logger>\n\t-->\n</configuration>\n```\n\n### 6. 修改banner\n1. 在src/main/resources目录下新建banner.txt文件\n\n### 7. 热部署\n1. 导入依赖\n```xml\n<!-- 热部署 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n2. 配置文件\n```yml\n# 热部署\nspring:\n  devtools:\n    restart:\n      enabled: true\n```\n\n### 8. 自动配置\n    推荐文章:\n    https://blog.csdn.net/qq_41805567/article/details/129111183",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 26,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-07T09:26:22.000+00:00",
        "updateTime": "2023-10-15T04:15:25.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": "想学会Java,Scala,Python,Golang,Mojo,C#, .NET",
          "userRole": "vip",
          "interests": [
            "Java",
            "Javascript",
            "Java 基础",
            "Springcloud",
            "Spring",
            "Go",
            "MongoDB",
            "面试题",
            "前端",
            "GitHub",
            "网页",
            "简历",
            "后端",
            "Python",
            "项目",
            "算法",
            "框架",
            "Vue"
          ],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 10,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-10-13T03:33:21.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Java 基础",
          "Spring"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1709490834266779650",
        "title": "前端构建工具 ：SWC",
        "description": "前端构建工具对比",
        "content": "> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​\t所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/bMD1KmN9-鱼聪明AI绘画.jpeg",
        "language": null,
        "viewNum": 24,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-04T08:49:10.000+00:00",
        "updateTime": "2023-10-17T06:33:40.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 12,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-10-11T01:17:28.000+00:00"
        },
        "tags": [
          "文章",
          "前端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1708492976759631873",
        "title": "前端页面渲染策略：SSR CSR ISR SSG",
        "description": "前端页面渲染策略 SSR CSR ISR SSG，因为一些网站可能会更关心SEO，一些可能更关心性能或者数据的实时性，每种策略都有它们擅长的场景",
        "content": "### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/MoX2S3aj-鱼聪明AI绘画.jpeg",
        "language": null,
        "viewNum": 20,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-10-01T14:44:02.000+00:00",
        "updateTime": "2023-10-18T02:16:02.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 12,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-10-11T01:17:28.000+00:00"
        },
        "tags": [
          "文章",
          "前端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1707630098880000001",
        "title": "JavaWeb项目",
        "description": "一个纯原生JavaWeb(servlet+jsp)项目",
        "content": "# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1629476488245968898/4H37XePS-QQ图片20230929133422.png",
        "language": null,
        "viewNum": 51,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1629476488245968898",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-29T05:35:16.000+00:00",
        "updateTime": "2023-10-17T06:39:15.000+00:00",
        "user": {
          "id": "1629476488245968898",
          "planetCode": "16792",
          "userName": "无名",
          "userAvatar": null,
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-05-15T02:38:12.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-25T13:40:43.000+00:00",
          "updateTime": "2023-06-01T17:41:15.000+00:00"
        },
        "tags": [
          "文章",
          "项目",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "177",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "23"
  },
  "message": "ok"
}